<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>C++ | PeaceKeeper</title><meta name=keywords content><meta name=description content><meta name=author content="Jacob"><link rel=canonical href=https://yangzh313.github.io/categories/c++/><link crossorigin=anonymous href=/assets/css/stylesheet.min.49b1c3611e5e823e974d0b9b3e1101617fce26c004757161abb1a1e4af3ff85c.css integrity="sha256-SbHDYR5egj6XTQubPhEBYX/OJsAEdXFhq7Gh5K8/+Fw=" rel="preload stylesheet" as=style><link rel=icon href=https://yangzh313.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://yangzh313.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://yangzh313.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://yangzh313.github.io/apple-touch-icon.png><link rel=mask-icon href=https://yangzh313.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><link rel=alternate type=application/rss+xml href=https://yangzh313.github.io/categories/c++/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="C++"><meta property="og:description" content><meta property="og:type" content="website"><meta property="og:url" content="https://yangzh313.github.io/categories/c++/"><meta name=twitter:card content="summary"><meta name=twitter:title content="C++"><meta name=twitter:description content></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://yangzh313.github.io/ accesskey=h title="PeaceKeeper (Alt + H)">PeaceKeeper</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://yangzh313.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://yangzh313.github.io/archives/ title=Archive><span>Archive</span></a></li><li><a href=https://yangzh313.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://yangzh313.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><header class=page-header><h1>C++</h1></header><article class="post-entry tag-entry"><header class=entry-header><h2>【Linux】程序内获取文件系统挂载信息</h2></header><section class=entry-content><p>link
Linux shell可通过查看/etc/mtab或者/proc/mounts文件来获取当前文件系统挂载信息
程序内读取/etc/mtab或者/proc/mounts，解析字符串较为繁琐，可以使用mntent提供的方便函数：
FILE *setmntent(const char *filename, const char *type); struct mntent *getmntent(FILE *filep); int endmntent(FILE *filep); （1）setmntent用来打开/etc/mtab或者同样格式的table文件 参数 filename为table文件的路径（例如/etc/mtab），参数type为打开文件的模式（与open类型，例如“r”为只读打开） 成功时，返回FILE指针（用于mntent操作），失败时返回NULL
（2）getmntent用来读取文件的每一行，解析每一行的参数到mntent结构，mntent结构的存储空间是静态分配的（不需要free），结构的值会在下一次getmntent时被覆盖 mntent结构定义:
struct mntent { char *mnt_fsname; /* 文件系统对应的设备路径或者服务器地址 */ char *mnt_dir; /* 文件系统挂载到的系统路径 */ char *mnt_type; /* 文件系统类型: ufs, nfs, 等 */ char *mnt_opts; /* 文件系统挂载参数，以逗号分隔 */ int mnt_freq; /* 文件系统备份频率（以天为单位） */ int mnt_passno; /* 开机fsck的顺序，如果为0，不会进行check */ }; 参数filep是setmntent返回的FILE指针 成功时返回指向mntent的指针，错误时返回NULL
（3）endmntent用来关闭打开的table文件，总是返回1
示例程序：
#include &lt;stdio.h> #include &lt;mntent.h> #include &lt;errno....</p></section><footer class=entry-footer><span title='2022-05-20 00:00:00 +0000 UTC'>May 20, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;Jacob</footer><a class=entry-link aria-label="post link to 【Linux】程序内获取文件系统挂载信息" href=https://yangzh313.github.io/page/c++/setmntent/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>leak check</h2></header><section class=entry-content><p>valgrind download use
leak check with valgrind valgrind --leak-check=full --show-leak-kinds=all --tool=memcheck bin/protector-server -f -c /etc/protector/protector.conf ==952002== ==952002== HEAP SUMMARY: ==952002== in use at exit: 364,554 bytes in 983 blocks ==952002== total heap usage: 1,071,487 allocs, 1,070,504 frees, 642,510,809 bytes allocated ==952002== ==952002== 23 bytes in 1 blocks are still reachable in loss record 1 of 41 ==952002== at 0x4C31593: operator new(unsigned long) (vg_replace_malloc.c:344) ==952002== by 0x5756A0E: void std::__cxx11::basic_string&lt;char, std::char_traits&lt;char>, std::allocator&lt;char> >::_M_construct&lt;char*>(char*, char*, std::forward_iterator_tag) (basic_string....</p></section><footer class=entry-footer><span title='2022-05-20 00:00:00 +0000 UTC'>May 20, 2022</span>&nbsp;·&nbsp;44 min&nbsp;·&nbsp;Jacob</footer><a class=entry-link aria-label="post link to leak check" href=https://yangzh313.github.io/page/c++/leak_check/></a></article><article class="post-entry tag-entry"><header class=entry-header><h2>mutex</h2></header><section class=entry-content><p>C++11中新增了，它是C++标准程序库中的一个头文件，定义了C++11标准中的一些互斥访问的类与方法等。其中std::mutex就是lock、unlock。std::lock_guard与std::mutex配合使用，把锁放到lock_guard中时，mutex自动上锁，lock_guard析构时，同时把mutex解锁。mutex又称互斥量。
C++11标准库定义了4个互斥类：
(1)、std::mutex：该类表示普通的互斥锁, 不能递归使用。
(2)、std::timed_mutex：该类表示定时互斥锁，不能递归使用。std::time_mutex比std::mutex多了两个成员函数：
A、try_lock_for()：函数参数表示一个时间范围，在这一段时间范围之内线程如果没有获得锁则保持阻塞；如果在此期间其他线程释放了锁，则该线程可获得该互斥锁；如果超时(指定时间范围内没有获得锁)，则函数调用返回false。
B、try_lock_until()：函数参数表示一个时刻，在这一时刻之前线程如果没有获得锁则保持阻塞；如果在此时刻前其他线程释放了锁，则该线程可获得该互斥锁；如果超过指定时刻没有获得锁，则函数调用返回false。
(3)、std::recursive_mutex：该类表示递归互斥锁。递归互斥锁可以被同一个线程多次加锁，以获得对互斥锁对象的多层所有权。例如，同一个线程多个函数访问临界区时都可以各自加锁，执行后各自解锁。std::recursive_mutex释放互斥量时需要调用与该锁层次深度相同次数的unlock()，即lock()次数和unlock()次数相同。可见，线程申请递归互斥锁时，如果该递归互斥锁已经被当前调用线程锁住，则不会产生死锁。此外，std::recursive_mutex的功能与 std::mutex大致相同。
(4)、std::recursive_timed_mutex：带定时的递归互斥锁。
互斥类的最重要成员函数是lock()和unlock()。在进入临界区时，执行lock()加锁操作，如果这时已经被其它线程锁住，则当前线程在此排队等待。退出临界区时，执行unlock()解锁操作。
用于互斥锁的RAII的类模板：更好的办法是采用”资源分配时初始化”(RAII)方法来加锁、解锁，这避免了在临界区中因为抛出异常或return等操作导致没有解锁就退出的问题。极大地简化了程序员编写Mutex相关的异常处理代码。C++11的标准库中提供了std::lock_guard类模板做mutex的RAII。
std::mutex类是一个同步原语，可用于保护共享数据被同时由多个线程访问。std::mutex提供独特的，非递归的所有权语义。
std::mutex是C++11中最基本的互斥量，std::mutex对象提供了独占所有权的特性，不支持递归地对std::mutex对象上锁。
std::mutex成员函数：
(1)、构造函数：std::mutex不支持copy和move操作，最初的std::mutex对象是处于unlocked状态。
(2)、lock函数：互斥锁被锁定。线程申请该互斥锁，如果未能获得该互斥锁，则调用线程将阻塞(block)在该互斥锁上；如果成功获得该互诉锁，该线程一直拥有该互斥锁直到调用unlock解锁；如果该互斥锁已经被当前调用线程锁住，则产生死锁(deadlock)。
(3)、unlock函数：解锁，释放调用线程对该互斥锁的所有权。
(4)、try_lock：尝试锁定互斥锁。如果互斥锁被其他线程占有，则当前调用线程也不会被阻塞，而是由该函数调用返回false；如果该互斥锁已经被当前调用线程锁住，则会产生死锁。其中std::mutex就是lock、unlock。std::lock_guard与std::mutex配合使用，把锁放到lock_guard中时，mutex自动上锁，lock_guard析构时，同时把mutex解锁。
(5)、native_handle：返回当前句柄。
std::mutex: A mutex is a lockable object that is designed to signal when critical sections of code need exclusive access, preventing other threads with the same protection from executing concurrently and access the same memory locations. std::mutex objects provide exclusive ownership and do not support recursivity (i.e., a thread shall not lock a mutex it already owns)....</p></section><footer class=entry-footer><span title='2022-05-20 00:00:00 +0000 UTC'>May 20, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;Jacob</footer><a class=entry-link aria-label="post link to mutex" href=https://yangzh313.github.io/page/c++/mutex/></a></article></main><footer class=footer><span>&copy; 2022 <a href=https://yangzh313.github.io/>PeaceKeeper</a></span><br><span>Powered by
<a href=https://github.com/sawhney17/logseq-schrodinger rel=noopener target=_blank>Logseq Schrödinger</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>