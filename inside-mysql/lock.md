# 6 Lock

一方面最大程度地利用数据库的并发访问，另外一方面还要却确保每个用户能以一致的方式读取和修改数据。

## 6.1 What is lock?

锁机制用于管理对共享资源的并发访问。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。

## 6.2 lock and latch

latch，轻量级锁，锁定时间短，否则性能差。在InnoDB中，分为mutex（互斥锁）和rwlock（读写锁）。通常没有死锁检测机制。目的是保证并发线程操作临界资源的正确性。
lock，对象是事务，如表、页、行。一般在事务commit或rollback后释放。具有死锁机制。

## 6.3 InnoDB存储引擎中的锁

### 6.3.1 type

行级锁：

* 共享锁（S Lock），允许事务读一行数据。
* 排他锁（X Lock），允许事务删除或更新一行数据。

X锁与任何锁都不兼容，而S锁仅和S锁兼容。

InnoDB存储引擎支持多粒度（granular）锁定，这种锁定允许事务在航机上的锁和表级上的锁同时存在，称为意向锁（Intention Lock）。
其意向锁为表级别的锁，设计的目的主要是为了在一个事务中解释下一行将被请求的锁类型。支持两种意向锁：

* 意向共享锁（IS Lock），事务想要获得一张表中某几行的共享锁。
* 意向排他锁（IX Lock），事务想要获得一张表中某几行的排他锁。

由于InnoDB存储引擎支持的是行级别的锁，因此意向锁其实不会阻塞除全表扫意外的任何请求。

### 6.3.2 一致性非锁定读

consistent nonlocking read是指通过行多版本空值的方式读取当前执行时间数据库中行的数据。如果读取的行正在执行DELETE或UPDATE操作，此时不会等待锁的释放，而是读取行的一个快照数据。

一个行记录可能有不止一个快照数据，一把称这种技术为行多版本技术。由此带来的并发控制，称之为多版本控制(Multi Version Concurrency Control, MVCC).

对于REPEATABLE READ的事务隔离级别，总是读取事务开始时的行数据。对于READ COMMITTED的事务隔离级别，它总是读取行的最新版本。

### 6.3.3 一致性锁定读

InnoDB存储引擎对于SELECT语句支持两种一致性的锁定读操作：

* SELECT...FOR UPDATE
* SELECT...LOCK IN SHARE MODE

### 6.3.4 自增长与锁

在InnoDB存储引擎的内存结构中，对每个含有自增长值的表都有一个自增长计数器。

### 6.3.5 外键和锁

对于一个外键列，如果没有显示地对这个列加索引，InnoDB存储引擎自动对其加一个索引，这样可以避免表锁。

## 6.4 锁的算法

### 6.4.1 行锁的3种算法

* Record Lock：单个行记录上的锁
* Gap Lock：间隙锁，锁定一个范围，但不包括记录本身
* Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身

### 6.4.2 解决Phantom Problem

默认REPEATABLE READ事务隔离级别下，InnoDB存储引擎采用Next-Key Locking机制避免幻读问题。
Phantom Problem是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。

## 6.5 锁问题

### 6.5.1 脏读 (Dirty Read)

脏数据是指事务对缓冲池中行记录的修改，并且还没有被提交。如果读到另外一个事务中未提交的数据，违反了数据库的**事务隔离性**。
在READ UNCOMMITTED事务隔离级别，两次SELECT由于未提交的数据发生了更改取得了不同的结果，产生了脏读。
在slave节点上不需要特别精确的返回值，在某些情况下可设置为READ UNCOMMITTED。

### 6.5.2 不可重复读

在一次事务中，两次读到的数据不一样的情况，成为不可重复读。
脏读读到未提交的数据，而不可重复读读到的是已经提交的事务。
违反了数据库事务一致性的要求。
在MySQL官方文档中定义为Phantom Problem。在默认级别READ REPEATABLE，采用Next-Key Lock算法下，避免了不可重复读的现象。

### 6.5.3 丢失更新

丢失更新是另一个锁导致的问题，简单来说就是一个事务的更新操作会被另一个事务的更新操作所覆盖，从而导致数据的不一致。例如：

1. 事务T1将行记录r更新为v1，事务T1未提交。
2. 同时，事务T2将行记录r更新为v2，事务T2未提交。
3. 事务T1提交。
4. 事务T2提交。

## 6.6 阻塞

在有些时刻一个事务中的锁需要等待另一个食物中的锁释放它锁占用的资源，这就是阻塞。

默认情况下，InnoDB存储引擎不会回滚超时引发的错误异常。用户需要判断是否COMMIT还是ROLLBACK，之后再进行下一步的操作。

## 6.7 死锁

### 6.7.1 死锁的概念

死锁是指两个或两个以上的事务在执行过程中，因争渡锁资源而造成的一种互相等待的现象。
一种解决方法是超时，当一个事务超过某一阈值时，其中一个事务进行回滚。在InnoDB中，参数innodb_lock_wait_timeout用来设置超时的时间。
除了超时机制，普遍采用wait-for graph（等待图）的方式进行死锁检测。要求数据库保存以下两种信息：

* 锁的信息链表
* 事务等待链表
通过上述链表可以构造出一张图，若图中存在回路，就代表存在死锁。InnoDB引擎会回滚undo量最小的事务。

### 6.7.2 死锁概率

事务发生死锁的概率与以下几点因素有关：

* 系统中事务的数量，数量越多概率越大。
* 每个事务操作的数量，越多概率越大。
* 操作数据的集合，越小则发生死锁的概率越大。

## 6.8 锁升级

锁升级（Lock Escalation）是指将当前锁的粒度降低。如果数据库认为锁是一种稀有的资源，在适合的时候会自动地将行、键或分页锁升级为更粗粒度的表级锁。
