- > 本文由 [简悦 SimpRead](http://ksria.com/simpread/) 转码， 原文地址 [www.cnblogs.com](https://www.cnblogs.com/DaBing0806/p/14207809.html)
  
  ![](http://5b0988e595225.cdn.sohucs.com/images/20180724/9fbd2352874e48a9b0ffb50202175ea9.jpeg)
  
  这里我们先区分好两个概念：文件描述符和文件句柄
  
  简单来说，每个进程都有一个打开的文件表（fdtable)。表中的每一项是 struct file 类型，包含了打开文件的一些属性比如偏移量，读写访问模式等，这是真正意义上的文件句柄。
  
  文件描述符是一个整数。代表 fdtable 中的索引位置（下标），指向具体的 struct file（文件句柄）。
  
  哪些地方会分配文件句柄？
  
  知道文件句柄最终是通过 get_empty_filp 函数从 filp cache 中分配的之后，我们顺着函数调用链路简单梳理下，就能知道有哪些地方会分配文件句柄了：
  
  *   open 系统调用打开文件（path_openat 内核函数)
  *   打开一个目录（dentry_open 函数)
  *   共享内存 attach （do_shmat 函数）
  *   socket 套接字（sock_alloc_file 函数）
  *   管道（create_pipe_files 函数）
  *   epoll/inotify/signalfd 等功能用到的匿名 inode 文件系统（anon_inode_getfile 函数)
  
  file-nr 文件里面的第一个字段代表的是内核分配的 struct file 的个数，也就是文件句柄个数，而不是文件描述符
  
  机器上的常常会出现文件句柄使用量与常用的 lsof 命令的数量相去甚远的情况
  
  ![](https://img2020.cnblogs.com/blog/782306/202012/782306-20201229172520359-2068968917.png)
- ```
  [root@zymysql ~]# cat /proc/sys/fs/file-nr
  1504    0       761384
  [root@zymysql ~]#
  [root@zymysql ~]# lsof |wc -l
  8672
  ```
- linux下查看进程占用句柄数： `ls -l /proc/进程ID/fd | wc -l`
- 因为文件描述符和文件句柄是两个不同的东西：lsof 在用户空间，主要还是从文件描述符的角度来看文件句柄。
  
  我们来做一个实验：只打开一次文件，然后复制 1000 次文件描述符。
  
  我们启动 dupfd 进程打开了一次 / dev/zero 文件，复制了 1000 次文件描述符。file-nr 中的文件句柄数只是个位数的变化，而 lsof 看到的结果涨了 1000 多。
  
  如果我们把前面的代码换成 open 1000 次， 就可以看到 file-nr 和 lsof 的输出几乎都涨了 1000。
  
  我们循环 1000 次打开 / dev/zero 文件，之后 mmap 映射到进程地址空间，然后把这些打开的文件描述符都关掉。很显然，打开的描述符都被 close 掉了，不会有什么变化。 那为什么文件句柄数还是增加了 1000 个左右呢？
  
  原来，linux 内核中很多对象都是有引用计数的。 虽然文件句柄是由 open 先打开的，但 mmap 之后，引用计数被加 1，尽管我们接着把文件描述符 close 掉了，但是底层指向的 struct file 由于引用数大于 0，不会被回收。
  
  通过上面两个例子，你应该知道 lsof 的输出和实际的文件句柄数有差距的原因了。